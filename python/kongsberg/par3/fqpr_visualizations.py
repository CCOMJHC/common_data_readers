import numpy as np

import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation, FFMpegWriter
import matplotlib.cm as cm
from mpl_toolkits.mplot3d import Axes3D


class FqprVisualizations:
    """
    Visualizations in Matplotlib built on top of FQPR class

    Processed FQPR is passed in as argument
    """
    def __init__(self, fqpr):
        self.fqpr = fqpr

        self.orientation_sector = None
        self.orientation_quiver = None
        self.orientation_figure = None
        self.orientation_objects = None
        self.orientation_anim = None

        self.bpv_quiver = None
        self.bpv_dat = None
        self.bpv_datsec = None
        self.bpv_figure = None
        self.bpv_objects = None
        self.bpv_anim = None

    def alongacross_plot_3d(self, secid=None, tme=None):
        """
        Plots a 3d representation of the alongtrack/acrosstrack/depth values generated by sv correct.  If sector is
        provided, isolates that sector.  If a time is provided, isolates that time.

        Parameters
        ----------
        secid: string, optional if you wish to only plot that sector
        tme: float, optional if you wish to only plot for that time

        Returns
        -------
        ax: matplotlib axes object for plot

        """
        minz = self.fqpr.calc_min_var('depth_offset')
        maxz = self.fqpr.calc_max_var('depth_offset')
        miny = self.fqpr.calc_min_var('acrosstrack_offset')
        maxy = self.fqpr.calc_max_var('acrosstrack_offset')

        fig = plt.figure()
        ax = fig.add_subplot(111, projection='3d')

        if secid is None:
            secid = self.fqpr.return_sector_ids()
        for sec in secid:
            if tme is not None:
                if tme in self.fqpr.fqpr[sec].time:
                    dat = self.fqpr.fqpr[sec].sel(time=tme)
                    x = dat.alongtrack_offset
                    y = dat.acrosstrack_offset
                    z = dat.depth_offset
                else:
                    print('Unable to find time {} in sector {}'.format(tme, sec))
                    continue
            else:
                dat = self.fqpr.fqpr[sec]
                x = dat.alongtrack_offset.stack(stck=('time', 'beam'))
                y = dat.acrosstrack_offset.stack(stck=('time', 'beam'))
                z = dat.depth_offset.stack(stck=('time', 'beam'))

            x = x[~np.isnan(x)]
            y = y[~np.isnan(y)]
            z = z[~np.isnan(z)]
            ax.scatter(x, y, -z)
            ax.set_xlim(miny, maxy)
        return ax

    def alongacross_plot_2d(self, secid=None, tme=None):
        """
        Plots a 2d representation of the acrosstrack/depth values generated by sv correct.  If sector is
        provided, isolates that sector.  If a time is provided, isolates that time.

        Parameters
        ----------
        secid: string, optional if you wish to only plot that sector
        tme: float, optional if you wish to only plot for that time

        Returns
        -------
        fig: matplotlib.pyplot.figure instance
        """
        # 1495563085.4482062 for em2040_smallfil
        minz = self.fqpr.calc_min_var('depth_offset')
        maxz = self.fqpr.calc_max_var('depth_offset')
        miny = self.fqpr.calc_min_var('acrosstrack_offset')
        maxy = self.fqpr.calc_max_var('acrosstrack_offset')

        fig = plt.figure()

        if secid is None:
            secid = self.fqpr.return_sector_ids()
        for sec in secid:
            if tme is not None:
                if tme in self.fqpr.fqpr[sec].time:
                    dat = self.fqpr.fqpr[sec].sel(time=tme)
                    x = dat.alongtrack_offset
                    y = dat.acrosstrack_offset
                    z = dat.depth_offset
                else:
                    print('Unable to find time {} in sector {}'.format(tme, sec))
                    continue
            else:
                dat = self.fqpr.fqpr[sec]
                x = dat.alongtrack_offset.stack(stck=('time', 'beam'))
                y = dat.acrosstrack_offset.stack(stck=('time', 'beam'))
                z = dat.depth_offset.stack(stck=('time', 'beam'))

            x = x[~np.isnan(x)]
            y = y[~np.isnan(y)]
            z = z[~np.isnan(z)]

            scaledz = (z - minz) / (maxz - minz)
            colors = plt.cm.coolwarm(scaledz)

            plt.scatter(y, x, marker='+', c=colors, s=5)
        plt.ylim(miny, maxy)
        return fig

    def _generate_orientation_vector(self, secid, tme=None):
        """
        Generate tx/rx vector data for given time value, return with values to be used with matplotlib quiver

        Parameters
        ----------
        secid: string, sector identifier
        tme: float, time at this specific interval

        Returns
        -------
        x: tuple, x component of starting location of vectors
        y: tuple, y component of starting location of vectors
        z: tuple, z component of starting location of vectors
        u: tuple, x direction component of vectors
        v: tuple, y direction component of vectors
        w: tuple, z direction component of vectors

        """
        if tme is not None:
            tx = self.fqpr.tx_vecs[secid].sel(time=tme).values
            rx = self.fqpr.rx_vecs[secid].sel(time=tme).values
        else:
            tx = self.fqpr.tx_vecs[secid].isel(time=0).values
            rx = self.fqpr.rx_vecs[secid].isel(time=0).values
        # rx = rx[~np.all(np.isnan(rx), axis=1)]  # dont include the nan vector entries
        rx = np.nanmean(rx, axis=0)
        origin = [0, 0, 0]
        x, y, z = zip(origin, origin)
        u, v, w = zip(tx, rx)
        return x, y, z, u, v, w

    def _update_orientation_vector(self, time):
        """
        Update method for visualize_orientation_vector, runs on each frame of the animation

        Parameters
        ----------
        time: float, time at this specific interval

        Returns
        -------
        self.orientation_quiver: matplotlib quiver, two vectors for tx/rx (blue, red)
        self.orientation_objects: dict, objects to draw on the plot

        """
        vecdata = self._generate_orientation_vector(self.orientation_sector, time)
        tx_x = round(vecdata[3][0], 3)
        tx_y = round(vecdata[4][0], 3)
        tx_z = round(vecdata[5][0], 3)
        rx_x = round(vecdata[3][1], 3)
        rx_y = round(vecdata[4][1], 3)
        rx_z = round(vecdata[5][1], 3)

        self.orientation_quiver.remove()
        self.orientation_quiver = self.orientation_figure.quiver(*vecdata, color=['blue', 'red'])
        self.orientation_objects['time'].set_text('Time: {:0.3f}'.format(time))
        self.orientation_objects['tx_vec'].set_text('TX Vector: x:{:0.3f}, y:{:0.3f}, z:{:0.3f}'.format(tx_x, tx_y, tx_z))
        self.orientation_objects['rx_vec'].set_text('RX Vector: x:{:0.3f}, y:{:0.3f}, z:{:0.3f}'.format(rx_x, rx_y, rx_z))

    def visualize_orientation_vector(self, secid=None):
        """
        Use matplotlib funcanimation to build animated representation of the transmitter/receiver across time

        Receiver orientation is based on attitude at the average time of receive (receive time differs across beams)

        Parameters
        ----------
        secid: string, sector identifier for the sector we are interested in

        Returns
        -------
        self.orientation_anim: matplotlib FuncAnimation instance, 3d visualization of the transmitter/receiver
                               orientations across time

        """
        if secid is None:
            secid = list(self.fqpr.fqpr.keys())[0]

        self.orientation_objects = {}
        self.fqpr.tx_vecs[secid] = self.fqpr.tx_vecs[secid].compute()
        self.fqpr.rx_vecs[secid] = self.fqpr.rx_vecs[secid].compute()

        fig = plt.figure(figsize=(10, 8))
        self.orientation_figure = fig.add_subplot(111, projection='3d')
        self.orientation_figure.set_xlim(-1.2, 1.2)
        self.orientation_figure.set_ylim(-1.2, 1.2)
        self.orientation_figure.set_zlim(-1.2, 1.2)
        self.orientation_figure.set_xlabel('+ Forward')
        self.orientation_figure.set_ylabel('+ Starboard')
        self.orientation_figure.set_zlabel('+ Down')

        self.orientation_objects['time'] = self.orientation_figure.text2D(-0.1, 0.11, '')
        self.orientation_objects['tx_vec'] = self.orientation_figure.text2D(0, 0.11, '', color='blue')
        self.orientation_objects['rx_vec'] = self.orientation_figure.text2D(0, 0.10, '', color='red')

        tme_interval = (self.fqpr.tx_vecs[secid].time.values[1] - self.fqpr.tx_vecs[secid].time.values[0]) * 1000
        print('Animating with frame interval of {}'.format(int(tme_interval)))
        self.orientation_sector = secid

        self.orientation_quiver = self.orientation_figure.quiver(*self._generate_orientation_vector(secid),
                                                                 color=['blue', 'red'])
        self.orientation_anim = FuncAnimation(fig, self._update_orientation_vector,
                                              frames=self.fqpr.tx_vecs[secid].time.values, interval=tme_interval)

    def _generate_bpv_arrs(self, dat):
        """
        Generate traveltime/beampointingangle vectors to be used with matplotlib quiver

        Parameters
        ----------
        dat: list, beampointingangle/twowaytraveltime reformed across sectors

        Returns
        -------
        x: tuple, x component of starting location of vectors
        y: tuple, y component of starting location of vectors
        u: tuple, x direction component of vectors
        v: tuple, y direction component of vectors

        """
        bpa = np.array(dat[0]).ravel()
        tt = np.array(dat[1]).ravel()

        maxbeams = bpa.shape[0]
        u = np.sin(bpa) * tt
        v = np.cos(bpa) * tt
        u = -u / np.max(u)  # negative here for beam pointing angle so the port angles (pos) are on the left side
        v = -v / np.max(v)  # negative here for travel time so the vectors point down in the graph

        x = np.zeros(maxbeams)
        y = np.zeros(maxbeams)
        return x, y, u, v

    def _update_bpv(self, idx):
        """
        Update method for visualize_beam_pointing_vectors, runs on each frame of the animation

        Parameters
        ----------
        idx: int, ping counter index

        Returns
        -------
        self.bpv_quiver: matplotlib quiver, x vectors for bpa/twtt for each beam, colored by sector
        self.bpv_objects: dict, objects to draw on the plot

        """
        if self.bpv_quiver is not None:
            self.bpv_quiver.remove()
        if self.fqpr.source_dat.is_dual_head():
            pouterang = [round(np.rad2deg(self.bpv_dat[0, idx, 0]), 3), round(np.rad2deg(self.bpv_dat[0, idx + 1, 0]), 3)]
            poutertt = [round(self.bpv_dat[1, idx, 0], 3), round(self.bpv_dat[1, idx + 1, 0], 3)]
            pinnerang = [round(np.rad2deg(self.bpv_dat[0, idx, -1]), 3), round(np.rad2deg(self.bpv_dat[0, idx + 1, -1]), 3)]
            pinnertt = [round(self.bpv_dat[1, idx, -1], 3), round(self.bpv_dat[1, idx + 1, -1], 3)]
            idx = [idx, idx + 1]
        else:
            pouterang = round(self.bpv_dat[0, idx, 0], 3)
            poutertt = round(self.bpv_dat[1, idx, 0], 3)
            pinnerang = round(self.bpv_dat[0, idx, -1], 3)
            pinnertt = round(self.bpv_dat[1, idx, -1], 3)

        self.bpv_quiver = self.bpv_figure.quiver(*self._generate_bpv_arrs(self.bpv_dat[:, idx, :]),
                                                 color=self._generate_bpv_colors(self.bpv_datsec[0, idx, :].ravel()),
                                                 units='xy', scale=1)
        self.bpv_objects['Time'].set_text('Ping: {}'.format(idx))

        self.bpv_objects['Port_outer_angle'].set_text('Port outermost angle: {}°'.format(pouterang))
        self.bpv_objects['Port_outer_traveltime'].set_text('Port outermost traveltime: {}s'.format(poutertt))
        self.bpv_objects['Starboard_outer_angle'].set_text('Starboard outermost angle: {}°'.format(pinnerang))
        self.bpv_objects['Starboard_outer_traveltime'].set_text('Starboard outermost traveltime: {}s'.format(pinnertt))

    def _generate_bpv_colors(self, datsec):
        """
        Return colormap for beams identifying unique sectors as different colors

        Parameters
        ----------
        datsec: array of sector identifiers associated with each beam

        Returns
        -------
        matplotlib colormap for that ping, colored by sector

        """
        unique_sectors = np.unique(datsec)
        newsec = datsec
        for u in unique_sectors:
            # replace sector identifiers with an integer index
            newsec = np.where(newsec == u, np.where(unique_sectors == u)[0][0], newsec)
        colormap = cm.rainbow
        newsec = newsec.astype(np.int)
        if np.max(newsec) > 0:
            # scale for the max integer count of sectors
            return colormap(newsec / np.max(newsec))
        else:
            return colormap(newsec)

    def _determine_bpv_framerate(self, timestmps):
        """
        Given the timestamps provided to the animation, determine the frame rate.

        Some sonars have two pings, diff freq each ping.  Identify the max gap to build the framerate

        Parameters
        ----------
        timestmps: numpy array of timestamps

        Returns
        -------
        maxdif: float, framerate for the plot
        """
        diff_tstmps = np.diff(timestmps[0:10])
        if len(diff_tstmps) > 1:
            multiplier = np.mean(diff_tstmps) * 1000
        else:
            multiplier = 1000
        maxdif = diff_tstmps[np.argmax(diff_tstmps)] * multiplier
        return maxdif

    def visualize_beam_pointing_vectors(self):
        """
        Use matplotlib funcanimation to build animated representation of the beampointingvectors/traveltimes across
        time

        Returns
        -------
        self.bpv_anim: matplotlib FuncAnimation instance, 3d visualization of the beampointingvectors/traveltimes
                       across time

        """
        # since we are going to be animating using periodic calls to the dataset, lets just compute those values
        #    ahead of time so it isn't computing each xarray call
        for sec in self.fqpr.fqpr:
            self.fqpr.fqpr[sec]['beam_pointing_angle'] = self.fqpr.fqpr[sec]['beam_pointing_angle'].compute()
            self.fqpr.fqpr[sec]['two_way_travel_time'] = self.fqpr.fqpr[sec]['two_way_travel_time'].compute()

        self.bpv_objects = {}
        unique_times = self.fqpr.return_unique_times_across_sectors()

        fig = plt.figure(figsize=(10, 8))
        self.bpv_figure = fig.add_subplot(1, 1, 1)

        self.bpv_figure.set_xlim(-1.5, 1.5)
        self.bpv_figure.set_ylim(-1.5, 0.5)
        self.bpv_figure.set_xlabel('Acrosstrack (scaled)')
        self.bpv_figure.set_ylabel('Travel Time (scaled)')
        self.bpv_figure.set_axis_off()

        self.bpv_objects['Time'] = self.bpv_figure.text(-1.4, 0.45, '')
        self.bpv_objects['Port_outer_angle'] = self.bpv_figure.text(-1.4, 0.40, '')
        self.bpv_objects['Port_outer_traveltime'] = self.bpv_figure.text(-1.4, 0.35, '')
        self.bpv_objects['Starboard_outer_angle'] = self.bpv_figure.text(0.35, 0.40, '')
        self.bpv_objects['Starboard_outer_traveltime'] = self.bpv_figure.text(0.35, 0.35, '')

        self.bpv_dat, self.bpv_datsec = self.fqpr.reform_vars_across_sectors_at_time(['beam_pointing_angle',
                                                                                      'two_way_travel_time'],
                                                                                     unique_times)

        if self.fqpr.source_dat.is_dual_head():
            frames = [i * 2 for i in range(int(self.bpv_dat.shape[1]/2))]
        else:
            frames = [i for i in range(int(self.bpv_dat.shape[1]))]
        self.bpv_anim = FuncAnimation(fig, self._update_bpv, frames=frames, interval=100)


def save_animation_mpeg(anim_instance, output_pth):
    ffwriter = FFMpegWriter()
    anim_instance.save(output_pth, writer=ffwriter)